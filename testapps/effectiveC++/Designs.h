/*
 * Designs.h
 *
 *  Created on: Oct 30, 2013
 *      Author: dimitrios
 */

#ifndef DESIGNS_H_
#define DESIGNS_H_

#include<iostream>
#include<stdio.h>
#include<string.h>
#include<vector>


typedef enum
{
	MONDAY,
	TUESDAY
}day_t;

typedef enum
{
	JANUARY,
	FEBRUARY

}month_t;

struct Day
{
	explicit Day(int val) :
			m_val(val)
	{

	}

private:
	int m_val;
};

struct Month
{
	explicit Month(int val) :
			m_val(val)
	{

	}

private:
	int m_val;
};

struct Year
{
	explicit Year(int val) :
			m_val(val)
	{

	}

private:
	int m_val;
};

class Rationals
{
public:
	Rationals(int denominator= 0, int nominator= 0) :
		m_den(denominator),
		m_nom(nominator)
	{
		std::cout << "Constructor called " << std::endl;
	}

	~Rationals()
	{
		std::cout << "Destructor called" << std::endl;
	}

#if 0
	//this will not allow think like Rational * 1;
	const Rationals operator*(const Rationals& rhs)
	{
		return Rationals(this->m_den, rhs.m_nom);
	}

	friend const Rationals operator*(const Rationals& lhs, const Rationals& rhs)
	{
		//static Rationals result;
		//result= Rationals(lhs.m_den*rhs.m_den, rhs.m_den*lhs.m_nom);
		//return result;
		return Rationals(lhs.m_den, rhs.m_nom);
	}
#endif


private:
	int m_den;
	int m_nom;
};

const Rationals operator*(const Rationals& lhs, const Rationals& rhs)
{
	//static Rationals result;
	//result= Rationals(lhs.m_den*rhs.m_den, rhs.m_den*lhs.m_nom);
	//return result;
	return Rationals(0, 1);
}

namespace WebBrowserStuff
{
//use the core stuff here
class WebBrowser
{
public:

public:

	void clearCache() const
	{

	}

	void clearHistory() const
	{

	}

	void removeCookies() const
	{

	}

};

//you can put it in a different source file and minimize compilation dependencies
void clearEverything(const WebBrowser& web)
{
	web.clearCache();
	web.clearHistory();
	web.removeCookies();
}
}

//PIMPL idiom
//THIS CAN GO TO IMPLEMENTATION FILE
class WidgetImpl
{
private:
	int a,b,c;
	std::vector<int> v;
};

class MyException : public std::exception
{
	 virtual const char* what() const throw()
	 {
		 return "custom exception";
	 }

};

//THIS CAN BE IN A HEADER !!!!
class Widgets
{

public:

	Widgets() :
		m_impl(new WidgetImpl())
	{
#if 0
		//NOTE: All this code is generated by the compiler
		//When exception is thrown then all parts of the object will be destroyed
		try
		{
			//destroy any base calls here as well
			this->~Widgets();
		}
		catch (int e)
		{
			//Re through the exception here in order to let the client
			//know that we have failed
			throw;
		}
#endif
	}
	Widgets(const Widgets& wid) :
		m_impl(NULL)
	{

	}

	~Widgets()
	{
		if (m_impl)
		{
			delete m_impl;
			m_impl= NULL;
		}
		std::cout << "Widget destructor has been called: " << std::endl;
	}

	explicit Widgets(int m) :
			m_impl(NULL)
	{

	}

	const Widgets& operator=(const Widgets& widget)
	{
		*m_impl= *widget.m_impl;
		return *this;
	}

	//To swap is just enough to flip the pointers
	void swap(Widgets& other)
	{
		WidgetImpl* temp= this->m_impl;
		this->m_impl=other.m_impl;
		other.m_impl= temp;
		std::cout << "Swap being called " << std::endl;
	}
private:
	WidgetImpl* m_impl;
};

void doSomeWidgetWork(const Widgets& widget)
{

}








#endif /* DESIGNS_H_ */
